[![Build Status](https://travis-ci.org/maeteno/design-pattern-java.svg?branch=master)](https://travis-ci.org/maeteno/design-pattern-java)

下面的对模式的描述不一定非常准确，甚至可能会误导。所以如果你不幸的看到了，请只作为参考。以下解释一般基于自己理解。更加准确详细的描述请参考以下连接

[Blog](https://blog.maeteno.me/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)  

[菜鸟教程](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)  

# 创建型模式
创建型模式都是设计和解决如何创建对象和生成对象的模式

## Factory
工厂模式就是通过一个类去创建对象，而不是自己直接的去创建对象。使用者只要告诉工厂对象你需要的对象是什么。工厂会返回一个你需要的对象，例如通过数据库的表明获取一个对应的ORM对象。

## Abstract Factory
抽象工厂模式就是对工厂模式的升级，抽象工厂返回的不是一个可以直接使用的对象，而是一个工厂。

## Singleton
单例模式就是保证这个类的对象只有一个，一般可以作为一个全局的对象来使用。类似与别的语言中的全局变量。在面向对象语言中一般都是将构造函数私有化来实现的。

## Builder
构造者模式，其实是对复用的另外一种实现。建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。就像组装汽车一样。

## Prototype
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。可以说原型模式就是克隆模式。

# 结构型模式
结构型的设计模式决定了代码的结构，类之间的关系和调用依赖。

## 适配器模式（Adapter Pattern）
目标兼容已有接口，兼容模式

## 桥接模式（Bridge Pattern）
依赖注入，通过更换相关对象，可改变一个对象的行为

## 组合模式（Composite Pattern）

## 装饰器模式（Decorator Pattern）
修饰一个已经存在的类的行为。不改变原有的类，给原有的类添加额外的功能。但是并不能改变一个类的内部行为，有点像一个中间件，在一个类的动作之前或之后添加而外的功能。典型的例如Python的装饰器，java的注解（这个我没有太深入的研究，感觉应该也是的）。
